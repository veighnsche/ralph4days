// TODO: MCP Generator - Generate bash MCP servers for Claude to access .ralph/db/
//
// This module generates MCP server configs that expose ralph database operations
// as tools/resources that Claude can use.
//
// TODO LIST:
// 1. Add tool: create_task(feature, discipline, title, description, ...)
//    - Should call ralph database commands
//    - Return task ID on success
//
// 2. Add tool: create_feature(name, display_name, description, ...)
//    - Normalize name to lowercase-with-hyphens
//    - Return success/error
//
// 3. Add tool: create_discipline(name, display_name, icon, color, ...)
//    - Add to disciplines.yaml
//    - Return success/error
//
// 4. Add tool: update_task_status(task_id, status)
//    - Update task status in tasks.yaml
//    - Validate status is valid (pending, in_progress, done)
//
// 5. Add resource: list_tasks, list_features, list_disciplines
//    - Read-only access to current state
//    - Return as JSON or formatted text
//
// 6. Mode-specific permissions:
//    - "braindump": create_task, create_feature, create_discipline (full write)
//    - "yap-tasks": create_task, update_task_status (task-focused)
//    - "ramble-features": create_feature, update_feature (feature-focused)
//    - "interactive": read-only list operations
//
// 7. Error handling in generated scripts
//    - Validate inputs before writing to YAML
//    - Return helpful error messages
//    - Don't crash on malformed input

use std::path::{Path, PathBuf};

/// Generates bash-based MCP server scripts that give Claude access to .ralph/db/ files.
///
/// Each Ralph process gets its own temp dir (PID-scoped) for isolation.
/// Scripts use pure bash (no jq dependency).
pub struct MCPGenerator {
    base_dir: PathBuf,
}

impl Default for MCPGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl MCPGenerator {
    pub fn new() -> Self {
        let base_dir = std::env::temp_dir().join(format!("ralph-mcp-{}", std::process::id()));
        Self { base_dir }
    }

    /// Generate an MCP config for the given mode and ralph db path.
    /// Returns the path to the MCP config JSON file.
    pub fn generate(&self, mode: &str, ralph_db_path: &Path) -> Result<PathBuf, String> {
        std::fs::create_dir_all(&self.base_dir)
            .map_err(|e| format!("Failed to create MCP temp dir: {}", e))?;

        let script_path = self.base_dir.join(format!("mcp-{}.sh", mode));
        let config_path = self.base_dir.join(format!("mcp-{}.json", mode));

        // Sanitize path for bash: escape single quotes
        let db_path_str = ralph_db_path.to_string_lossy().replace('\'', "'\\''");

        let script = match mode {
            "task_creation" => Self::generate_task_creation_script(&db_path_str),
            _ => Self::generate_interactive_script(&db_path_str),
        };

        std::fs::write(&script_path, script)
            .map_err(|e| format!("Failed to write MCP script: {}", e))?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            std::fs::set_permissions(&script_path, std::fs::Permissions::from_mode(0o755))
                .map_err(|e| format!("Failed to chmod MCP script: {}", e))?;
        }

        // Sanitize paths for JSON too
        let script_json = script_path
            .to_string_lossy()
            .replace('\\', "\\\\")
            .replace('"', "\\\"");
        let db_json = ralph_db_path
            .to_string_lossy()
            .replace('\\', "\\\\")
            .replace('"', "\\\"");

        let config = format!(
            r#"{{"mcpServers":{{"ralph":{{"command":"{}","args":["{}"]}}}}}}"#,
            script_json, db_json,
        );

        std::fs::write(&config_path, config)
            .map_err(|e| format!("Failed to write MCP config: {}", e))?;

        Ok(config_path)
    }

    /// Helper bash function that extracts the JSON-RPC "id" from a request line.
    /// MCP protocol requires responses echo back the request's id field.
    fn id_extractor() -> &'static str {
        r#"# Extract JSON-RPC request ID from a line
extract_id() {
    local line="$1"
    local id=""
    # Match "id": followed by a number or quoted string
    if [[ "$line" =~ \"id\"[[:space:]]*:[[:space:]]*([0-9]+) ]]; then
        id="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ \"id\"[[:space:]]*:[[:space:]]*\"([^\"]+)\" ]]; then
        id="\"${BASH_REMATCH[1]}\""
    else
        id="null"
    fi
    echo "$id"
}

# Escape a string for safe JSON embedding
json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\n'/\\n}"
    s="${s//$'\t'/\\t}"
    s="${s//$'\r'/}"
    echo "$s"
}
"#
    }

    fn generate_task_creation_script(db_path: &str) -> String {
        format!(
            r#"#!/usr/bin/env bash
# Generated by Ralph — MCP server for task creation
# Provides tools: list_features, list_disciplines, read_tasks
RALPH_DB='{db_path}'

{id_extractor}

while IFS= read -r line; do
    id=$(extract_id "$line")

    if [[ "$line" == *'"initialize"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"protocolVersion":"2024-11-05","capabilities":{{"tools":{{}},"resources":{{}}}},"serverInfo":{{"name":"ralph-mcp","version":"1.0.0"}}}}}}\n' "$id"
    elif [[ "$line" == *'"tools/list"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"tools":[{{"name":"list_features","description":"List all features in the project","inputSchema":{{"type":"object","properties":{{}}}}}},{{"name":"list_disciplines","description":"List all disciplines in the project","inputSchema":{{"type":"object","properties":{{}}}}}},{{"name":"read_tasks","description":"Read all tasks","inputSchema":{{"type":"object","properties":{{}}}}}}]}}}}\n' "$id"
    elif [[ "$line" == *'"tools/call"'* ]]; then
        if [[ "$line" == *'"list_features"'* ]]; then
            content=$(json_escape "$(cat "$RALPH_DB/features.yaml" 2>/dev/null || echo "No features found")")
            printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"%s"}}]}}}}\n' "$id" "$content"
        elif [[ "$line" == *'"list_disciplines"'* ]]; then
            content=$(json_escape "$(cat "$RALPH_DB/disciplines.yaml" 2>/dev/null || echo "No disciplines found")")
            printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"%s"}}]}}}}\n' "$id" "$content"
        elif [[ "$line" == *'"read_tasks"'* ]]; then
            content=$(json_escape "$(cat "$RALPH_DB/tasks.yaml" 2>/dev/null || echo "No tasks found")")
            printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"%s"}}]}}}}\n' "$id" "$content"
        fi
    elif [[ "$line" == *'"resources/list"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"resources":[]}}}}\n' "$id"
    elif [[ "$line" == *'"notifications/"'* ]]; then
        : # notifications require no response
    fi
done
"#,
            db_path = db_path,
            id_extractor = Self::id_extractor(),
        )
    }

    fn generate_interactive_script(db_path: &str) -> String {
        format!(
            r#"#!/usr/bin/env bash
# Generated by Ralph — MCP server for interactive sessions
# Provides tools + resources for full read/write access to .ralph/db/
RALPH_DB='{db_path}'

{id_extractor}

while IFS= read -r line; do
    id=$(extract_id "$line")

    if [[ "$line" == *'"initialize"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"protocolVersion":"2024-11-05","capabilities":{{"tools":{{}},"resources":{{}}}},"serverInfo":{{"name":"ralph-mcp","version":"1.0.0"}}}}}}\n' "$id"
    elif [[ "$line" == *'"tools/list"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"tools":[{{"name":"read_db_file","description":"Read a file from .ralph/db/","inputSchema":{{"type":"object","properties":{{"filename":{{"type":"string","description":"File name (e.g. tasks.yaml)"}}}}}}}},{{"name":"list_db_files","description":"List files in .ralph/db/","inputSchema":{{"type":"object","properties":{{}}}}}}]}}}}\n' "$id"
    elif [[ "$line" == *'"tools/call"'* ]]; then
        if [[ "$line" == *'"read_db_file"'* ]]; then
            # Extract filename from arguments
            fname="${{line#*\"filename\":\"}}"
            fname="${{fname%%\"*}}"
            if [[ -f "$RALPH_DB/$fname" ]]; then
                content=$(json_escape "$(cat "$RALPH_DB/$fname")")
                printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"%s"}}]}}}}\n' "$id" "$content"
            else
                printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"File not found: %s"}}]}}}}\n' "$id" "$fname"
            fi
        elif [[ "$line" == *'"list_db_files"'* ]]; then
            files=$(ls "$RALPH_DB" 2>/dev/null | tr '\n' ', ')
            printf '{{"jsonrpc":"2.0","id":%s,"result":{{"content":[{{"type":"text","text":"Files: %s"}}]}}}}\n' "$id" "$files"
        fi
    elif [[ "$line" == *'"resources/list"'* ]]; then
        printf '{{"jsonrpc":"2.0","id":%s,"result":{{"resources":[{{"uri":"ralph://db/tasks.yaml","name":"tasks.yaml","mimeType":"text/yaml"}},{{"uri":"ralph://db/features.yaml","name":"features.yaml","mimeType":"text/yaml"}},{{"uri":"ralph://db/disciplines.yaml","name":"disciplines.yaml","mimeType":"text/yaml"}},{{"uri":"ralph://db/metadata.yaml","name":"metadata.yaml","mimeType":"text/yaml"}}]}}}}\n' "$id"
    elif [[ "$line" == *'"resources/read"'* ]]; then
        # Extract URI
        uri="${{line#*\"uri\":\"}}"
        uri="${{uri%%\"*}}"
        fname="${{uri#ralph://db/}}"
        if [[ -f "$RALPH_DB/$fname" ]]; then
            content=$(json_escape "$(cat "$RALPH_DB/$fname")")
            printf '{{"jsonrpc":"2.0","id":%s,"result":{{"contents":[{{"uri":"%s","mimeType":"text/yaml","text":"%s"}}]}}}}\n' "$id" "$uri" "$content"
        fi
    elif [[ "$line" == *'"notifications/"'* ]]; then
        : # notifications require no response
    fi
done
"#,
            db_path = db_path,
            id_extractor = Self::id_extractor(),
        )
    }
}

impl Drop for MCPGenerator {
    fn drop(&mut self) {
        // Clean up temp dir on shutdown
        let _ = std::fs::remove_dir_all(&self.base_dir);
    }
}
